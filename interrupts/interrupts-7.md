Interrupts and Interrupt Handling. Part 7.
================================================================================

Introduction to external interrupts
--------------------------------------------------------------------------------

<!---
This is the seventh part of the Interrupts and Interrupt Handling in the Linux kernel [chapter](http://0xax.gitbooks.io/linux-insides/content/interrupts/index.html) and in the previous [part](http://0xax.gitbooks.io/linux-insides/content/interrupts/interrupts-6.html) we have finished with the exceptions which are generated by the processor. In this part we will continue to dive to the interrupt handling and will start with the external hardware interrupt handling. As you can remember, in the previous part we have finished with the `trap_init` function from the [arch/x86/kernel/trap.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c) and the next step is the call of the `early_irq_init` function from the [init/main.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c).
--->
これは、[Linuxカーネルの割り込みハンドラと例外ハンドラの章](http://0xax.gitbooks.io/linux-insides/content/interrupts/index.html)の第七回です。
[前回](http://0xax.gitbooks.io/linux-insides/content/interrupts/interrupts-6.html)は、プロセッサに生成された例外について完了しました。
この回では、割り込み処理に潜ることを続け、外部ハードウェア割り込みについて始めます。
前回、[arch/x86/kernel/trap.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/
arch/x86/kernel/traps.c)の`trap_init`関すで終わっていました。次のステップは[init/main.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.
c)の`early_irq_init`関数の呼び出しです。

<!---
Interrupts are signal that are sent across [IRQ](https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29) or `Interrupt Request Line` by a hardware or software. External hardware interrupts allow devices like keyboard, mouse and etc, to indicate that it needs attention of the processor. Once the processor receives the `Interrupt Request`, it will temporary stop execution of the running program and invoke special routine which depends on an interrupt. We already know that this routine is called interrupt handler (or how we will call it `ISR` or `Interrupt Service Routine` from this part). The `ISR` or `Interrupt Handler Routine` can be found in Interrupt Vector table that is located at fixed address in the memory. After the interrupt is handled processor resumes the interrupted process. At the boot/initialization time, the Linux kernel identifies all devices in the machine, and appropriate interrupt handlers are loaded into the interrupt table. As we saw in the previous parts, most exceptions are handled simply by the sending a [Unix signal](https://en.wikipedia.org/wiki/Unix_signal) to the interrupted process. That's why kernel is can handle an exception quickly. Unfortunately we can not use this approach for the external hardware interrupts, because often they arrive after (and sometimes long after) the process to which they are related has been suspended. So it would make no sense to send a Unix signal to the current process. External interrupt handling depends on the type of an interrupt:
--->
割り込みは、ハードウェアやソフトウェアによって、[IRQ](https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29)（`Interrupt Request Line`）を介して送信されるシグナルです。
外部ハードウェア割り込みは、デバイス（キーボードやマウスなど）にプロセッサの注意が必要であることを示すこと可能にします。
一度、プロセッサが`Interrupt Request`を受け取ると、実行中のプログラムを一時的に止めて、割り込みに依存した特別なルーチンを起動します。
すでに、このルーチンが割り込みハンドラと呼ばれていることを知っています（この回からは、`ISR` や `Interrupt Service Routine`と呼ぶでしょう）。
`ISR`（`Interrupt Service Routine`）は、メモリの固定アドレスに配置された割り込みヴェクタテーブルに見つけることができます。
割り込みが処理された後、プロセッサは割り込まれたプロセスを再び始めます。
起動・初期化時に、Linuxカーネルはマシンのすべてのデバイスを検出し、適切な割り込みハンドラが割り込みテーブルに読み出されます。
前の回で見てきたように、多くの例外は割り込んだプロセスに[Unix signal](https://en.wikipedia.org/wiki/Unix_signal)を送信することで簡単に処理されました。
そのため、カーネルは例外を素早く処理できます。
不幸なことに、外部ハードウェア割り込みにはこのアプローチは使うことができません。
なぜなら、しばしばそれらが関連するプロセスが中断された後に（そして時には長く後に）到着するからです。
したがって、現在のプロセスにUnixシグナルを送るのは意味をなさないでしょう。
外部割り込み処理は、割り込みの種類によって異なります：

* `I/O` interrupts;
* Timer interrupts;
* Interprocessor interrupts.

<!---
I will try to describe all types of interrupts in this book.
--->
この本では割り込みのすべての種類について記述することを試みます。

<!---
Generally, a handler of an `I/O` interrupt must be flexible enough to service several devices at the same time. For example in the [PCI](https://en.wikipedia.org/wiki/Conventional_PCI) bus architecture several devices may share the same `IRQ` line. In the simplest way the Linux kernel must do following thing when an `I/O` interrupt occurred:
--->
一般的に`I/O`割り込みのハンドラは、同時に複数のデバイスにサービスを提供するために十分に柔軟である必要があります。
例えば、[PCI](https://en.wikipedia.org/wiki/Conventional_PCI)バスアーキテクチャでは、複数のデバイスは同じ`IRQ`ラインを共有します。
最も単純な方法で、Linuxカーネルは`I/O`割り込みが発生した時に以下のことを行います：

<!---
* Save the value of an `IRQ` and the register's contents on the kernel stack;
* Send an acknowledgment to the hardware controller which is servicing the `IRQ` line;
* Execute the interrupt service routine (next we will call it `ISR`) which is associated with the device;
* Restore registers and return from an interrupt;
--->
* `IRQ`の値とレジスタのコンテンツの値とをカーネルスタックに保存します
* `IRQ`ラインをサービスするハードウェアコントローラに応答を送信します
* デバイスに関連する割り込みサービスルーチン（以降、`ISR`と呼びます）を実行します
* レジスタを復旧して、割り込みから返ります

<!---
Ok, we know a little theory and now let's start with the `early_irq_init` function. The implementation of the `early_irq_init` function is in the [kernel/irq/irqdesc.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c). This function make early initialization of the `irq_desc` structure. The `irq_desc` structure is the foundation of interrupt management code in the Linux kernel. An array of this structure, which has the same name - `irq_desc`, keeps track of every interrupt request source in the Linux kernel. This structure defined in the [include/linux/irqdesc.h](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irqdesc.h) and as you can note it depends on the `CONFIG_SPARSE_IRQ` kernel configuration option. This kernel configuration option enables support for sparse irqs. The `irq_desc` structure contains many different files:
--->
上記で少しの理論を知りました。今度は`early_irq_init`関数から始めましょう。
`early_irq_init`関数の実装は[kernel/irq/irqdesc.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/ke
rnel/irq/irqdesc.c)にあります。
この関数は`irq_desc`構造体の早期の初期化を行います。
`irq_desc`構造体はLinuxカーネルの割り込み管理コードの基盤です。
この構造体の配列（構造体と同じ名前の変数名で、`irq_desc`です）は、Linuxカーネルの個々の割り込み要求元を追跡します。
この構造体は[include/linux/irqdesc.h](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973
/include/linux/irqdesc.h)で定義され、`CONFIG_SPARSE_IRQ`カーネルコンフィギュレーションオプションに依存することに気がつくでしょう。
主要なフィールドを見ていきます：

<!---
* `irq_common_data` - per irq and chip data passed down to chip functions;
* `status_use_accessors` - contains status of the interrupt source which is combination of the values from the `enum` from the [include/linux/irq.h](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irq.h) and different macros which are defined in the same source code file;
* `kstat_irqs` - irq stats per-cpu;
* `handle_irq` - highlevel irq-events handler;
* `action` - identifies the interrupt service routines to be invoked when the [IRQ](https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29) occurs;
* `irq_count` - counter of interrupt occurrences on the IRQ line;
* `depth` - `0` if the IRQ line is enabled and a positive value if it has been disabled at least once; 
* `last_unhandled` - aging timer for unhandled count;
* `irqs_unhandled` - count of the unhandled interrupts;
* `lock`  - a spin lock used to serialize the accesses to the `IRQ` descriptor;
* `pending_mask` - pending rebalanced interrupts;
* `owner` - an owner of interrupt descriptor. Interrupt descriptors can be allocated from modules. This field is need to proved refcount on the module which provides the interrupts;
* and etc.
--->
* `irq_common_data` - chip関数へ渡されるirqとchip毎のデータ
* `status_use_accessors` - [include/linux/irq.h](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/inc
lude/linux/irq.h)で定義される`enum`値の組み合わせおよび同じソースにある異なるマクロである、割り込み要因のステータスを含む
* `kstat_irqs` - CPU毎のirq stats
* `handle_irq` - ハイレベルirqイベントハンドラ
* `action` - [IRQ](https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29)が発生した時に起動すべき割り込みサービスルーチンを識別する
* `irq_count` - IRQラインで生じた割り込み回数のカウンタ
* `depth` - IRQラインが有効なら`0`、少なくとも一度は無効にされたなら正の数値（ネステッドirq_disable()呼び出しのため）
* `last_unhandled` - 未処理カウントのエージングタイマー
* `irqs_unhandled` - 未処理の、似非割り込みのためのstatsフィールド
* `lock`  - SMPのための、スピンロック。`IRQ`デスクリプタへのシリーズなアクセスのため。
* `pending_mask` - 保留中の再バランス割り込み
* `owner` - 割り込みデスクリプタのオーナー。割り込みデスクリプタはモジュールからも確保できます。このフィールドは割り込みを提供するモジュールの参照カウンタを証明する必要があります。
* and etc.

<!---
Of course it is not all fields of the `irq_desc` structure, because it is too long to describe each field of this structure, but we will see it all soon. Now let's start to dive into the implementation of the `early_irq_init` function.
--->
もちろん、この構造体の各フィールドを記述するためには長すぎるので、`irq_desc`構造体のすべてのフィールドではありません。しかし、すぐにすべてを見ます。
`early_irq_init`関数の実装に飛び込んでいきましょう。


早期の外部割り込み初期化（Early external interrupts initialization）
--------------------------------------------------------------------------------

<!---
Now, let's look on the implementation of the `early_irq_init` function. Note that implementation of the `early_irq_init` function depends on the `CONFIG_SPARSE_IRQ` kernel configuration option. Now we consider implementation of the `early_irq_init` function when the `CONFIG_SPARSE_IRQ` kernel configuration option is not set. This function starts from the declaration of the following variables: `irq` descriptors counter, loop counter, memory node and the `irq_desc` descriptor:
--->
`early_irq_init`関数の実装を見てきましょう。
`early_irq_init`関数の実装は、`CONFIG_SPARSE_IRQ`カーネルコンフィギュレーションオプションに依存することに注意してください。
ここでは`CONFIG_SPARSE_IRQ`カーネルコンフィギュレーションオプションがセットされていない時の`early_irq_init`関数の実装を検討します。
この関数は次の変数の定義から開始します：`irq`デスクリプタカウンタ、ループカウンタ、メモリノード、IRQデスクリプタ（`irq_desc`構造体へのポインタ）：

```C
int __init early_irq_init(void)
{
        int count, i, node = first_online_node;
        struct irq_desc *desc;
		...
		...
		...
}
```

<!---
The `node` is an online [NUMA](https://en.wikipedia.org/wiki/Non-uniform_memory_access) node which depends on the `MAX_NUMNODES` value which depends on the `CONFIG_NODES_SHIFT` kernel configuration parameter:
--->
`node`は、`CONFIG_NODES_SHIFT`カーネルコンフィギュレーションパラメータに依存する`MAX_NUMNODES`の値に依存した有効な[NUMA](https://en.wikipedia.org/wiki/Non-uniform_memory_access)ノードです。

```C
#define MAX_NUMNODES    (1 << NODES_SHIFT)
...
...
...
#ifdef CONFIG_NODES_SHIFT
    #define NODES_SHIFT     CONFIG_NODES_SHIFT
#else
    #define NODES_SHIFT     0
#endif
```

<!---
As I already wrote, implementation of the `first_online_node` macro depends on the `MAX_NUMNODES` value:
--->
すでに書いたように、`first_online_node`マクロの実装は、`MAX_NUMNODES`の値に依存します：

```C
#if MAX_NUMNODES > 1
  #define first_online_node       first_node(node_states[N_ONLINE])
#else
  #define first_online_node       0  
```

<!---
The `node_states` is the [enum](https://en.wikipedia.org/wiki/Enumerated_type) which defined in the [include/linux/nodemask.h](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/nodemask.h) and represent the set of the states of a node. In our case we are searching an online node and it will be `0` if `MAX_NUMNODES` is one or zero. If the `MAX_NUMNODES` is greater than one, the `node_states[N_ONLINE]` will return `1` and the `first_node` macro will be expands to the call of the `__first_node` function which will return `minimal` or the first online node:
--->
`node_states`は、[include/linux/nodemask.h](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/nodemask.h)で定義された[列挙型（enum）](https://en.wikipedia.org/wiki/Enumerated_type)で、ノードの状態セットを表します。
ここでは、オンラインのノードを探しており、`MAX_NUMNODES`は１か０です。
`MAX_NUMNODES`が１より大きいなら、`node_states[N_ONLINE]`は `1`を返し、`first_node`マクロは`minimal`（最初のオンラインノード）を返す`__first_node`関数の呼び出しに展開されます。

```C
#define first_node(src) __first_node(&(src))

static inline int __first_node(const nodemask_t *srcp)
{
        return min_t(int, MAX_NUMNODES, find_first_bit(srcp->bits, MAX_NUMNODES));
}
```
<!---
More about this will be in the another chapter about the `NUMA`. The next step after the declaration of these local variables is the call of the:
--->
この詳細については、ほかの`NUMA`に関する章にあるでしょう。
これらのローカル変数定義のあと、次のステップは以下の関数呼び出しです：

```C
init_irq_default_affinity();
```

<!---
function. The `init_irq_default_affinity` function defined in the same source code file and depends on the `CONFIG_SMP` kernel configuration option allocates a given [cpumask](http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html) structure (in our case it is the `irq_default_affinity`):
--->
`init_irq_default_affinity`関数は同じソースコードファイルで定義され、`CONFIG_SMP`カーネルコンフィギュレーションオプションに依存します。
この関数は、与えられた[cpumask](http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html)構造体（ここでは、`irq_default_affinity`）を用いて確保します。

```C
#if defined(CONFIG_SMP)
cpumask_var_t irq_default_affinity;

static void __init init_irq_default_affinity(void)
{
        alloc_cpumask_var(&irq_default_affinity, GFP_NOWAIT);
        cpumask_setall(irq_default_affinity);
}
#else
static void __init init_irq_default_affinity(void)
{
}
#endif
```

<!---
We know that when a hardware, such as disk controller or keyboard, needs attention from the processor, it throws an interrupt. The interrupt tells to the processor that something has happened and that the processor should interrupt current process and handle an incoming event. In order to prevent multiple devices from sending the same interrupts, the [IRQ](https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29) system was established where each device in a computer system is assigned its own special IRQ so that its interrupts are unique. Linux kernel can assign certain `IRQs` to specific processors. This is known as `SMP IRQ affinity`, and it allows you control how your system will respond to various hardware events (that's why it has certain implementation only if the `CONFIG_SMP` kernel configuration option is set). After we allocated `irq_default_affinity` cpumask, we can see `printk` output:
--->
ディスクコントローラやキーボードなどのハードウェアがプロセッサから注意を必要とするとき、割り込みを投げることを知っています。
割り込みは、何かが起きたこと、プロセッサが現在のプロセスに割り込んで、入ってくるイベントを処理すべきことをプロセッサに通知します。
複数のデバイスが同じ割り込みを送信するのを防ぐために、[IRQ](https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29)システムは、コンピュータシステム内の各デバイスが独自の特殊IRQを割り当てられ、割り込みが一意になるように設定されました。
Linuxカーネルは、特定のプロセッサに所望の`IRQs`を割り当てることができます。
これは、`SMP IRQ affinity`として知られており、システムがさまざまなハードウェアイベントにどのように応答するかを制御できます。（`CONFIG_SMP`カーネルコンフィギュレーションオプションがセットされているときのみに、特定の実装を持っている理由です）。
`irq_default_affinity` cpumaskを確保したあと、`NR_IRQS`を出力する`printk`を見ることができます：

```C
printk(KERN_INFO "NR_IRQS:%d\n", NR_IRQS);
```

<!---
which prints `NR_IRQS`:
--->


```C
~$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352
```

<!---
The `NR_IRQS` is the maximum number of the `irq` descriptors or in another words maximum number of interrupts. Its value depends on the state of the `CONFIG_X86_IO_APIC` kernel configuration option. If the `CONFIG_X86_IO_APIC` is not set and the Linux kernel uses an old [PIC](https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller) chip, the `NR_IRQS` is:
--->
`NR_IRQS`は、`irq`デスクリプタの最大値です。言い換えると最大の割り込みの数です。
その値は`CONFIG_X86_IO_APIC`カーネルコンフィギュレーションオプションの状態に依存します。
`CONFIG_X86_IO_APIC`がセットされておらず、Linuxカーネルが古い[PIC](https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller)チップを使っているなら、`NR_IRQS`は、１６になります：

```C
#define NR_IRQS_LEGACY                    16

#ifdef CONFIG_X86_IO_APIC
...
...
...
#else
# define NR_IRQS                        NR_IRQS_LEGACY
#endif
```

<!---
In other way, when the `CONFIG_X86_IO_APIC` kernel configuration option is set, the `NR_IRQS` depends on the amount of the processors and amount of the interrupt vectors:
--->
ほかに、`CONFIG_X86_IO_APIC`カーネルコンフィギュレーションオプションがセットされているときは、`NR_IRQS`はプロセッサの量と割り込みヴェクタの量に依存します。

```C
#define CPU_VECTOR_LIMIT               (64 * NR_CPUS)
#define NR_VECTORS                     256
#define IO_APIC_VECTOR_LIMIT           ( 32 * MAX_IO_APICS )
#define MAX_IO_APICS                   128

# define NR_IRQS                                       \
        (CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ?     \
                (NR_VECTORS + CPU_VECTOR_LIMIT)  :     \
                (NR_VECTORS + IO_APIC_VECTOR_LIMIT))
...
...
...
```

<!---
We remember from the previous parts, that the amount of processors we can set during Linux kernel configuration process with the `CONFIG_NR_CPUS` configuration option:
--->
前の回から、プロセッサの量はLinuxカーネルコンフィギュレーションの中で、`CONFIG_NR_CPUS`コンフィギュレーションオプションで設定することができます。

![kernel](http://oi60.tinypic.com/1zdm1dt.jpg)

<!---
In the first case (`CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT`), the `NR_IRQS` will be `4352`, in the second case (`CPU_VECTOR_LIMIT < IO_APIC_VECTOR_LIMIT`), the `NR_IRQS` will be `768`. In my case the `NR_CPUS` is `8` as you can see in the my configuration, the `CPU_VECTOR_LIMIT` is `512` and the `IO_APIC_VECTOR_LIMIT` is `4096`. So `NR_IRQS` for my configuration is `4352`:
--->
最初のケース（`CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT`）は、`NR_IRQS`は`4352`となります。
２つめのケース（`CPU_VECTOR_LIMIT < IO_APIC_VECTOR_LIMIT`）は、`NR_IRQS`は`768`となります。
ここでは、`NR_CPU`が`8`として、`CPU_VECTOR_LIMIT`が`512`で、`IO_APIC_VECTOR_LIMIT`は`4096`です。
したがって、`NR_IRQSPは`4352`となります：

```
~$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352
```
<!---
In the next step we assign array of the IRQ descriptors to the `irq_desc` variable which we defined in the start of the `early_irq_init` function and calculate count of the `irq_desc` array with the `ARRAY_SIZE` macro:
--->
次のステップでは、IRQデスクリプタの配列を`early_irq_init`関数の開始時に定義した`irq_desc`変数へ代入し、
`irq_desc`配列の個数を、`ARRAY_SIZE`マクロを用いて計算します。

```C
desc = irq_desc;
count = ARRAY_SIZE(irq_desc);
```

<!---
The `irq_desc` array defined in the same source code file and looks like:
--->
`irq_desc`配列は同じソースコードファイルで定義され、以下のように見られます：

```C
struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
        [0 ... NR_IRQS-1] = {
                .handle_irq     = handle_bad_irq,
                .depth          = 1,
                .lock           = __RAW_SPIN_LOCK_UNLOCKED(irq_desc->lock),
        }
};
```

<!---
The `irq_desc` is array of the `irq` descriptors. It has three already initialized fields:
--->
`irq_desc`は`irq`デスクリプタの配列です。
３つの初期化されたフィールドを持っています。

* `handle_irq` - 上で書いたように、このフィールドはハイレベルのirq-eventハンドラです。
ここでは、[kernel/irq/handle.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/handle.c)で定義されている、未処理や偽のIRQを処理する`handle_bad_irq`関数で初期化されます。
* `depth` - IRQラインが有効なときは`0`で、少なくとも１度は割り込みを無効にされて入れば正の値です。
* `lock` - `IRQ`デスクリプタへのアクセスを直列化（serialize）するために使われるspin lock

<!---
* `handle_irq` - as I already wrote above, this field is the highlevel irq-event handler. In our case it initialized with the `handle_bad_irq` function that defined in the [kernel/irq/handle.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/handle.c) source code file and handles spurious and unhandled irqs;
* `depth` - `0` if the IRQ line is enabled and a positive value if it has been disabled at least once;
* `lock` - A spin lock used to serialize the accesses to the `IRQ` descriptor.
--->

As we calculated count of the interrupts and initialized our `irq_desc` array, we start to fill descriptors in the loop:

```C
for (i = 0; i < count; i++) {
    desc[i].kstat_irqs = alloc_percpu(unsigned int);
    alloc_masks(&desc[i], GFP_KERNEL, node);
    raw_spin_lock_init(&desc[i].lock);
    lockdep_set_class(&desc[i].lock, &irq_desc_lock_class);
	desc_set_defaults(i, &desc[i], node, NULL);
}
```

We are going through the all interrupt descriptors and do the following things:

First of all we allocate [percpu](http://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html) variable for the `irq` kernel statistic with the `alloc_percpu` macro. This macro allocates one instance of an object of the given type for every processor on the system. You can access kernel statistic from the userspace via `/proc/stat`:

```
~$ cat /proc/stat
cpu  207907 68 53904 5427850 14394 0 394 0 0 0
cpu0 25881 11 6684 679131 1351 0 18 0 0 0
cpu1 24791 16 5894 679994 2285 0 24 0 0 0
cpu2 26321 4 7154 678924 664 0 71 0 0 0
cpu3 26648 8 6931 678891 414 0 244 0 0 0
...
...
...
```

Where the sixth column is the servicing interrupts. After this we allocate [cpumask](http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html) for the given irq descriptor affinity and initialize the [spinlock](https://en.wikipedia.org/wiki/Spinlock) for the given interrupt descriptor. After this before the [critical section](https://en.wikipedia.org/wiki/Critical_section), the lock will be acquired with a call of the `raw_spin_lock` and unlocked with the call of the `raw_spin_unlock`. In the next step we call the `lockdep_set_class` macro which set the [Lock validator](https://lwn.net/Articles/185666/) `irq_desc_lock_class` class for the lock of the given interrupt descriptor. More about `lockdep`, `spinlock` and other synchronization primitives will be described in the separate chapter.

In the end of the loop we call the `desc_set_defaults` function from the [kernel/irq/irqdesc.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c). This function takes four parameters:

* number of a irq;
* interrupt descriptor;
* online `NUMA` node;
* owner of interrupt descriptor. Interrupt descriptors can be allocated from modules. This field is need to proved refcount on the module which provides the interrupts;

and fills the rest of the `irq_desc` fields. The `desc_set_defaults` function fills interrupt number, `irq` chip, platform-specific per-chip private data for the chip methods, per-IRQ data for the `irq_chip` methods and [MSI](https://en.wikipedia.org/wiki/Message_Signaled_Interrupts) descriptor for the per `irq` and `irq` chip data:

```C
desc->irq_data.irq = irq;
desc->irq_data.chip = &no_irq_chip;
desc->irq_data.chip_data = NULL;
desc->irq_data.handler_data = NULL;
desc->irq_data.msi_desc = NULL;
...
...
...
```

The `irq_data.chip` structure provides general `API` like the `irq_set_chip`, `irq_set_irq_type` and etc, for the irq controller [drivers](https://github.com/torvalds/linux/tree/master/drivers/irqchip). You can find it in the [kernel/irq/chip.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/chip.c) source code file.

After this we set the status of the accessor for the given descriptor and set disabled state of the interrupts:

```C
...
...
...
irq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS);
irqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);
...
...
...
```

In the next step we set the high level interrupt handlers to the `handle_bad_irq` which handles spurious and unhandled irqs (as the hardware stuff is not initialized yet, we set this handler), set `irq_desc.desc` to `1` which means that an `IRQ` is disabled, reset count of the unhandled interrupts and interrupts in general:

```C
...
...
...
desc->handle_irq = handle_bad_irq;
desc->depth = 1;
desc->irq_count = 0;
desc->irqs_unhandled = 0;
desc->name = NULL;
desc->owner = owner;
...
...
...
```

After this we go through the all [possible](http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html) processor with the [for_each_possible_cpu](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cpumask.h#L714) helper and set the `kstat_irqs` to zero for the given interrupt descriptor:

```C
	for_each_possible_cpu(cpu)
		*per_cpu_ptr(desc->kstat_irqs, cpu) = 0;
```

and call the `desc_smp_init` function from the [kernel/irq/irqdesc.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c) that initializes `NUMA` node of the given interrupt descriptor, sets default `SMP` affinity and clears the `pending_mask` of the given interrupt descriptor depends on the value of the `CONFIG_GENERIC_PENDING_IRQ` kernel configuration option:

```C
static void desc_smp_init(struct irq_desc *desc, int node)
{
        desc->irq_data.node = node;
        cpumask_copy(desc->irq_data.affinity, irq_default_affinity);
#ifdef CONFIG_GENERIC_PENDING_IRQ
        cpumask_clear(desc->pending_mask);
#endif
}
```
 
In the end of the `early_irq_init` function we return the return value of the `arch_early_irq_init` function:

```C
return arch_early_irq_init();
```

This function defined in the [kernel/apic/vector.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/apic/vector.c) and contains only one call of the `arch_early_ioapic_init` function from the [kernel/apic/io_apic.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/apic/io_apic.c). As we can understand from the `arch_early_ioapic_init` function's name, this function makes early initialization of the [I/O APIC](https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller). First of all it make a check of the number of the legacy interrupts with the call of the `nr_legacy_irqs` function. If we have no legacy interrupts with the [Intel 8259](https://en.wikipedia.org/wiki/Intel_8259) programmable interrupt controller we set `io_apic_irqs` to the `0xffffffffffffffff`: 

```C
if (!nr_legacy_irqs())
	io_apic_irqs = ~0UL;
```

After this we are going through the all `I/O APICs` and allocate space for the registers with the call of the `alloc_ioapic_saved_registers`:

```C
for_each_ioapic(i)
	alloc_ioapic_saved_registers(i);
```

And in the end of the `arch_early_ioapic_init` function we are going through the all legacy irqs (from `IRQ0` to `IRQ15`) in the loop and allocate space for the `irq_cfg` which represents configuration of an irq on the given `NUMA` node:

```C
for (i = 0; i < nr_legacy_irqs(); i++) {
    cfg = alloc_irq_and_cfg_at(i, node);
    cfg->vector = IRQ0_VECTOR + i;
    cpumask_setall(cfg->domain);
}
```

That's all.

Sparse IRQs
--------------------------------------------------------------------------------

We already saw in the beginning of this part that implementation of the `early_irq_init` function depends on the `CONFIG_SPARSE_IRQ` kernel configuration option. Previously we saw implementation of the `early_irq_init` function when the `CONFIG_SPARSE_IRQ` configuration option is not set, now let's look on the its implementation when this option is set. Implementation of this function very similar, but little differ. We can see the same definition of variables and call of the `init_irq_default_affinity` in the beginning of the `early_irq_init` function:

```C
#ifdef CONFIG_SPARSE_IRQ
int __init early_irq_init(void)
{
    int i, initcnt, node = first_online_node;
	struct irq_desc *desc;

	init_irq_default_affinity();
	...
	...
	...
}
#else
...
...
...
```

But after this we can see the following call:

```C
initcnt = arch_probe_nr_irqs();
```

The `arch_probe_nr_irqs` function defined in the [arch/x86/kernel/apic/vector.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/apic/vector.c) and calculates count of the pre-allocated irqs and update `nr_irqs` with its number. But stop. Why there are pre-allocated irqs? There is alternative form of interrupts called - [Message Signaled Interrupts](https://en.wikipedia.org/wiki/Message_Signaled_Interrupts) available in the [PCI](https://en.wikipedia.org/wiki/Conventional_PCI). Instead of assigning a fixed number of the interrupt request, the device is allowed to record a message at a particular address of RAM, in fact, the display on the [Local APIC](https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs). `MSI` permits a device to allocate `1`, `2`, `4`, `8`, `16` or `32` interrupts and `MSI-X` permits a device to allocate up to `2048` interrupts. Now we know that irqs can be pre-allocated. More about `MSI` will be in a next part, but now let's look on the `arch_probe_nr_irqs` function. We can see the check which assign amount of the interrupt vectors for the each processor in the system to the `nr_irqs` if it is greater and calculate the `nr` which represents number of `MSI` interrupts:

```C
int nr_irqs = NR_IRQS;

if (nr_irqs > (NR_VECTORS * nr_cpu_ids))
	nr_irqs = NR_VECTORS * nr_cpu_ids;

nr = (gsi_top + nr_legacy_irqs()) + 8 * nr_cpu_ids;
```

Take a look on the `gsi_top` variable. Each `APIC` is identified with its own `ID` and with the offset where its `IRQ` starts. It is called `GSI` base or `Global System Interrupt` base. So the `gsi_top` represents it. We get the `Global System Interrupt` base from the [MultiProcessor Configuration Table](https://en.wikipedia.org/wiki/MultiProcessor_Specification) table (you can remember that we have parsed this table in the sixth [part](http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-6.html) of the Linux Kernel initialization process chapter).

After this we update the `nr` depends on the value of the `gsi_top`:

```C
#if defined(CONFIG_PCI_MSI) || defined(CONFIG_HT_IRQ)
        if (gsi_top <= NR_IRQS_LEGACY)
                nr +=  8 * nr_cpu_ids;
        else
                nr += gsi_top * 16;
#endif
```

Update the `nr_irqs` if it less than `nr` and return the number of the legacy irqs:

```C
if (nr < nr_irqs)
    nr_irqs = nr;

return nr_legacy_irqs();
}
```

The next after the `arch_probe_nr_irqs` is printing information about number of `IRQs`:

```C
printk(KERN_INFO "NR_IRQS:%d nr_irqs:%d %d\n", NR_IRQS, nr_irqs, initcnt);
```

We can find it in the [dmesg](https://en.wikipedia.org/wiki/Dmesg) output:

```
$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352 nr_irqs:488 16
```

After this we do some checks that `nr_irqs` and `initcnt` values is not greater than maximum allowable number of `irqs`:

```C
if (WARN_ON(nr_irqs > IRQ_BITMAP_BITS))
    nr_irqs = IRQ_BITMAP_BITS;

if (WARN_ON(initcnt > IRQ_BITMAP_BITS))
    initcnt = IRQ_BITMAP_BITS;
```

where `IRQ_BITMAP_BITS` is equal to the `NR_IRQS` if the `CONFIG_SPARSE_IRQ` is not set and `NR_IRQS + 8196` in other way. In the next step we are going over all interrupt descriptors which need to be allocated in the loop and allocate space for the descriptor and insert to the `irq_desc_tree` [radix tree](http://0xax.gitbooks.io/linux-insides/content/DataStructures/radix-tree.html):

```C
for (i = 0; i < initcnt; i++) {
    desc = alloc_desc(i, node, NULL);
    set_bit(i, allocated_irqs);
	irq_insert_desc(i, desc);
}
```

In the end of the `early_irq_init` function we return the value of the call of the `arch_early_irq_init` function as we did it already in the previous variant when the `CONFIG_SPARSE_IRQ` option was not set:

```C
return arch_early_irq_init();
```

That's all.

Conclusion
--------------------------------------------------------------------------------

It is the end of the seventh part of the [Interrupts and Interrupt Handling](http://0xax.gitbooks.io/linux-insides/content/interrupts/index.html) chapter and we started to dive into external hardware interrupts in this part. We saw early initialization of the `irq_desc` structure which represents description of an external interrupt and contains information about it like list of irq actions, information about interrupt handler, interrupt's owner, count of the unhandled interrupt and etc. In the next part we will continue to research external interrupts.

If you have any questions or suggestions write me a comment or ping me at [twitter](https://twitter.com/0xAX).

**Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to [linux-insides](https://github.com/0xAX/linux-insides).**

Links
--------------------------------------------------------------------------------

* [IRQ](https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29)
* [numa](https://en.wikipedia.org/wiki/Non-uniform_memory_access)
* [Enum type](https://en.wikipedia.org/wiki/Enumerated_type)
* [cpumask](http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html)
* [percpu](http://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html)
* [spinlock](https://en.wikipedia.org/wiki/Spinlock)
* [critical section](https://en.wikipedia.org/wiki/Critical_section)
* [Lock validator](https://lwn.net/Articles/185666/)
* [MSI](https://en.wikipedia.org/wiki/Message_Signaled_Interrupts)
* [I/O APIC](https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller)
* [Local APIC](https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs)
* [Intel 8259](https://en.wikipedia.org/wiki/Intel_8259)
* [PIC](https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller)
* [MultiProcessor Configuration Table](https://en.wikipedia.org/wiki/MultiProcessor_Specification)
* [radix tree](http://0xax.gitbooks.io/linux-insides/content/DataStructures/radix-tree.html)
* [dmesg](https://en.wikipedia.org/wiki/Dmesg)
